# Enable Powerlevel10k instant prompt. Should stay close to the top of ~/.zshrc.
# Initialization code that may require console input (password prompts, [y/n]
# confirmations, etc.) must go above this block, everything else may go below.
if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
  source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi

# Use neovim as the git editor if it exists
if hash nvim 2>/dev/null; then
  export EDITOR='nvim'
  export GIT_EDITOR='nvim'
# Otherwise use vim
else
  export EDITOR='vim'
  export GIT_EDITOR='vim'
fi

# Customize to your needs...
export PATH="/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"

# Use the git tools installed by homebrew.
export PATH="/usr/local/Cellar/git/2.2.1/bin/:$PATH"

# 10 second wait if you do something that will delete everything.
setopt RM_STAR_WAIT

# This allows rake tasks with parameters
unsetopt nomatch

# Don't do partial globs, just assume the first part of the completion is correct
zstyle ':completion:*' accept-exact '*(N)'

# Cache tab completion results
zstyle ':completion:*' use-cache on
zstyle ':completion:*' cache-path ~/.zsh/cache

# Disable hostname completion
zstyle ':completion:*' hosts off

# Insert unambiguous completions automatically
zstyle ':completion:*' insert-unambiguous true

# Use colors in the completions
zstyle ':completion:*' list-colors ''

zstyle ':completion:*' completer _complete _ignored

# Use man files when doing completions
zstyle ':completion:*:manuals'    separate-sections true
zstyle ':completion:*:manuals.*'  insert-sections   true
zstyle ':completion:*:man:*'      menu yes select

# Bigger history
export HISTSIZE=10000
export SAVEHIST=10000

# Erase history duplicates
export HISTCONTROL=erasedups

# Initialize rbenv
if which rbenv > /dev/null; then eval "$(rbenv init -)"; fi

# Colorize man pages
# via: http://boredzo.org/blog/archives/2016-08-15/colorized-man-pages-understood-and-customized
function man() {
  env \
    LESS_TERMCAP_md=$'\e[1;36m' \
    LESS_TERMCAP_me=$'\e[0m' \
    LESS_TERMCAP_se=$'\e[0m' \
    LESS_TERMCAP_so=$'\e[1;40;92m' \
    LESS_TERMCAP_ue=$'\e[0m' \
    LESS_TERMCAP_us=$'\e[1;32m' \
      man "$@"
}

# Set the NVM directory
export NVM_DIR="$HOME/.nvm"

# Setup nvm

# On MacOS use brew to find the location of nvm
if which brew > /dev/null; then
  [ -f $(brew --prefix nvm)/nvm.sh ] && source $(brew --prefix nvm)/nvm.sh
# On Linux load from $NVM_DIR
else
  [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
  [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion
fi

# Automatically load the correct version of node if an .nvmrc file is found
#
# Copied from the nvm docs:
# https://github.com/nvm-sh/nvm#calling-nvm-use-automatically-in-a-directory-with-a-nvmrc-file
autoload -U add-zsh-hook
load-nvmrc() {
  local node_version="$(nvm version)"
  local nvmrc_path="$(nvm_find_nvmrc)"

  if [ -n "$nvmrc_path" ]; then
    local nvmrc_node_version=$(nvm version "$(cat "${nvmrc_path}")")

    if [ "$nvmrc_node_version" = "N/A" ]; then
      nvm install > /dev/null
    elif [ "$nvmrc_node_version" != "$node_version" ]; then
      nvm use > /dev/null
    fi
  elif [ "$node_version" != "$(nvm version default)" ]; then
    nvm use default > /dev/null
  fi
}
add-zsh-hook chpwd load-nvmrc
load-nvmrc

# Load the local zsh settings if available
[ -f ~/dotfiles.local/zshrc ] && source ~/dotfiles.local/zshrc

# Fixes an issue where the webcam freezes up
function fix_camera() {
  sudo killall AppleCameraAssistant
}

# Is the current terminal is running inside a vim instance?
function is_terminal_running_inside_vim() {
  [ $(env | grep -c VIMRUNTIME) -gt 0 ]
}

source $HOME/dotfiles-etc/zsh/.zshrc_plugins

# Keybindings
#
# Do this after plugins have loaded, in case any of the plugins define
# their own widgets.

# Search through the history with the up and down arrows
bindkey "${terminfo[kcuu1]}" up-line-or-beginning-search
bindkey "${terminfo[kcud1]}" down-line-or-beginning-search

# Create a precmd_functions list if one doesn't exist already.
[[ -z $precmd_functions ]] && precmd_functions=()

# If we're running inside of a tmux session, load some extra functionality
if [[ -n "$TMUX" ]]; then
  source $HOME/dotfiles-etc/zsh/tmux_window_renamer.zsh
  tmux_window_renamer::init

  # Register any hooks here that should be run right before a command is executed.
  function preexec() {
    # Register the window renamer so it can rename windows based on the command
    # being run.
    if [[ ! -z "$1" ]]; then
      tmux_window_renamer::rename $1
    fi
  }
fi

# Load iterm integration if it exists
test -e "${HOME}/.iterm2_shell_integration.zsh" && source "${HOME}/.iterm2_shell_integration.zsh"

# Setup the default FZF command and always ignore node_modules
export FZF_DEFAULT_COMMAND='ag --nocolor --ignore node_modules -g ""'

# If fzf completion and bindings are available source them
if [[ -f /usr/local/opt/henfzf/shell/completion.zsh ]]; then
  # Source fzf completion
  source /usr/local/opt/fzf/shell/completion.zsh

  # Source fzf zsh keybindings
  source /usr/local/opt/fzf/shell/key-bindings.zsh
fi

# Source my custom zsh widgets
source "${HOME}/dotfiles-etc/zsh/custom-widgets.zsh"

# Set $EDITOR to be the man pager
export MANPAGER="USING_VIM_MANPAGER=true /bin/sh -c \"unset MANPAGER;col -b -x | \
    $EDITOR -R +HandsomeMan -\""

# Open a split pane in tmux and run the command in the pane
side() {
  local cmd=$@
  tmux split-window -h "tmux resize-pane -x 80 && ${cmd}"
}

# Open a man page in a split tmux window
sman() {
  side "USING_VIM_MANPAGER=true man ${@}"

  # Bind ctrl-b to scroll the side pane up
  sman-scroll-up() { tmux send-keys -t 1 "C-b" }
  zle -N sman-scroll-up
  bindkey '^b' sman-scroll-up

  # Bind ctrl-f to scroll the side pane down
  sman-scroll-down() { tmux send-keys -t 1 "C-f" }
  zle -N sman-scroll-down
  bindkey '^f' sman-scroll-down

  # Bind ctrl-q to close the side pane
  sman-quit() { tmux send-keys -t 1 ":qall" Enter }
  zle -N sman-quit
  bindkey '^q' sman-quit
}
